---
layout: lecture
title: "Shell Tools and Scripting"
date: 2020-01-14
ready: true
video:
  aspect: 56.25
  id: kgII-YWo3Zw
---

এই বক্তৃতায়, আমরা বেশ কয়েকটি শেল সরঞ্জামের সাথে স্ক্রিপ্টিং ভাষা হিসাবে ব্যাশ ব্যবহার করার কিছু মৌলিক বিষয় উপস্থাপন করব যা আপনি কমান্ড লাইনে ক্রমাগত সম্পাদন করবেন এমন বেশ কয়েকটি সাধারণ কাজকে কভার করে।

#শেল স্ক্রিপ্টিং

এখন পর্যন্ত আমরা দেখেছি কিভাবে শেল এ কমান্ড এক্সিকিউট করা যায় এবং সেগুলিকে একসঙ্গে পাইপ করা যায়।
যাইহোক, অনেক পরিস্থিতিতে আপনি একাধিক কমান্ড সম্পাদন করতে চাইবেন এবং শর্তসাপেক্ষ বা লুপগুলির মতো নিয়ন্ত্রণ প্রবাহের অভিব্যক্তিগুলি ব্যবহার করতে চাইবেন।

শেল স্ক্রিপ্টগুলি জটিলতার পরবর্তী ধাপ।
বেশিরভাগ শেলের ভেরিয়েবল, নিয়ন্ত্রণ প্রবাহ এবং নিজস্ব বাক্য গঠন সহ তাদের নিজস্ব স্ক্রিপ্টিং ভাষা রয়েছে।
যা শেল স্ক্রিপ্টিংকে অন্যান্য স্ক্রিপ্টিং প্রোগ্রামিং ভাষার থেকে আলাদা করে তোলে তা হল এটি শেল-সম্পর্কিত কাজগুলি সম্পাদনের জন্য অনুকূলিত।
সুতরাং, কমান্ড পাইপলাইন তৈরি করা, ফাইলগুলিতে ফলাফল সংরক্ষণ করা এবং স্ট্যান্ডার্ড ইনপুট থেকে পড়া শেল স্ক্রিপ্টিংয়ের আদিম, যা সাধারণ উদ্দেশ্য স্ক্রিপ্টিং ভাষার তুলনায় ব্যবহার করা সহজ করে তোলে।
এই বিভাগের জন্য আমরা ব্যাশ স্ক্রিপ্টিংয়ের দিকে মনোনিবেশ করব কারণ এটি সবচেয়ে সাধারণ।

ব্যাশে ভেরিয়েবল বরাদ্দ করতে, 'foo = bar' সিনট্যাক্স ব্যবহার করুন এবং '$foo' দিয়ে ভেরিয়েবলের মান অ্যাক্সেস করুন।
লক্ষ্য করুন যে 'foo = bar' কাজ করবে না কারণ এটি আর্গুমেন্ট '=' এবং 'bar' সহ 'foo' প্রোগ্রামকে কল করা হিসাবে ব্যাখ্যা করা হয়।
সাধারণভাবে, শেল স্ক্রিপ্টে স্পেস চরিত্রটি আর্গুমেন্ট বিভাজন সম্পাদন করবে। এই আচরণটি প্রথমে ব্যবহার করা বিভ্রান্তিকর হতে পারে, তাই সর্বদা এটি পরীক্ষা করুন।

ব্যাশের স্ট্রিংগুলিকে 'এবং' সীমানা দ্বারা সংজ্ঞায়িত করা যেতে পারে, তবে সেগুলি সমতুল্য নয়।
'দিয়ে সীমাবদ্ধ স্ট্রিংগুলি আক্ষরিক স্ট্রিং এবং পরিবর্তনশীল মানগুলিকে প্রতিস্থাপন করবে না যেখানে' 'দ্বারা সীমাবদ্ধ স্ট্রিংগুলি প্রতিস্থাপন করবে।

```bash
foo=bar
echo "$foo"
# prints bar
echo '$foo'
# prints $foo
```

বেশিরভাগ প্রোগ্রামিং ভাষার মতো, ব্যাশ 'যদি', 'কেস', 'যখন' এবং 'জন্য' সহ নিয়ন্ত্রণ প্রবাহ কৌশলগুলিকে সমর্থন করে।
একইভাবে, 'ব্যাশ'-এর এমন ফাংশন রয়েছে যা আর্গুমেন্ট গ্রহণ করে এবং তাদের সাথে কাজ করতে পারে। এখানে এমন একটি ফাংশনের উদাহরণ দেওয়া হল যা একটি ডিরেক্টরি এবং 'সিডি' তৈরি করে।


```bash
mcd () {
    mkdir -p "$1"
    cd "$1"
}
```

এখানে '$1' হল স্ক্রিপ্ট/ফাংশনের প্রথম আর্গুমেন্ট।
অন্যান্য স্ক্রিপ্টিং ভাষার বিপরীতে, ব্যাশ আর্গুমেন্ট, ত্রুটি কোড এবং অন্যান্য প্রাসঙ্গিক ভেরিয়েবল বোঝাতে বিভিন্ন বিশেষ ভেরিয়েবল ব্যবহার করে। নিচে তার কয়েকটি তালিকা দেওয়া হলো। আরও বিস্তৃত তালিকা পাওয়া যাবে [এখানে] (https://tldp.org/LDP/abs/html/spacial-chars.html)
- '$0'-স্ক্রিপ্টের নাম-'$1' থেকে '$9' - স্ক্রিপ্টে যুক্তি। '$1' হল প্রথম আর্গুমেন্ট ইত্যাদি।
- '$@'-সমস্ত যুক্তি
- '$#'-আর্গুমেন্টের সংখ্যা-'$?' - আগের কমান্ডের রিটার্ন কোড-'$$' - বর্তমান স্ক্রিপ্টের জন্য প্রসেস আইডেন্টিফিকেশন নম্বর (পিআইডি)-'! '-আর্গুমেন্ট সহ সম্পূর্ণ শেষ কমান্ড। একটি সাধারণ প্যাটার্ন হল শুধুমাত্র অনুমতি না থাকার কারণে ব্যর্থ হওয়ার জন্য একটি কমান্ড এক্সিকিউট করা; আপনি 'sudo! '!
- '$_'-শেষ কমান্ড থেকে শেষ যুক্তি। আপনি যদি একটি ইন্টারেক্টিভ শেলের মধ্যে থাকেন, তাহলে আপনি 'Esc' এর পরে '.' বা 'Alt +' টাইপ করে দ্রুত এই মানটি পেতে পারেন।

কমান্ডগুলি প্রায়শই 'STDOUT' ব্যবহার করে আউটপুট, 'STDERR' এর মাধ্যমে ত্রুটি এবং আরও স্ক্রিপ্ট-বান্ধব পদ্ধতিতে ত্রুটিগুলি রিপোর্ট করার জন্য একটি রিটার্ন কোড প্রদান করে।
রিটার্ন কোড বা এক্সিট স্ট্যাটাস হল স্ক্রিপ্ট/কমান্ডগুলি কীভাবে কার্যকর হয়েছিল তা যোগাযোগ করার উপায়।
0 এর একটি মান সাধারণত বোঝায় যে সবকিছু ঠিক আছে; 0 থেকে ভিন্ন কিছু মানে একটি ত্রুটি ঘটেছে।

প্রস্থান কোডগুলি শর্তসাপেক্ষভাবে '& &' (এবং অপারেটর) এবং '।।' (বা অপারেটর) ব্যবহার করে কমান্ডগুলি কার্যকর করতে ব্যবহার করা যেতে পারে যা উভয়ই [short-circuiting] (https://en.wikipedia.org/wiki/Short-circuit_evaluation) অপারেটর। কমান্ডগুলি ';' ব্যবহার করে একই লাইনের মধ্যেও পৃথক করা যেতে পারে।
'সত্য' প্রোগ্রামে সর্বদা একটি 0 রিটার্ন কোড থাকবে এবং 'মিথ্যা' কমান্ডের সর্বদা একটি 1 রিটার্ন কোড থাকবে।
আসুন কিছু উদাহরণ দেখি

```bash
false || echo "Oops, fail"
# Oops, fail

true || echo "Will not be printed"
#

true && echo "Things went well"
# Things went well

false && echo "Will not be printed"
#

true ; echo "This will always run"
# This will always run

false ; echo "This will always run"
# This will always run
```

আরেকটি সাধারণ প্যাটার্ন হল পরিবর্তনশীল হিসাবে একটি কমান্ডের আউটপুট পেতে চাওয়া। এটি _ কমান্ড প্রতিস্থাপন _ দিয়ে করা যেতে পারে।
যখনই আপনি '$(CMD)' রাখবেন এটি 'CMD' এক্সিকিউট করবে, কমান্ডের আউটপুট পাবেন এবং এটিকে প্রতিস্থাপন করবেন।
উদাহরণস্বরূপ, আপনি যদি '$(ls)-এ ফাইলের জন্য' করেন, তবে শেলটি প্রথমে 'ls' কল করবে এবং তারপরে সেই মানগুলির উপর পুনরাবৃত্তি করবে।
একটি কম পরিচিত অনুরূপ বৈশিষ্ট্য হল _ process substitute _, '<(CMD)' 'CMD' এক্সিকিউট করবে এবং আউটপুটটিকে একটি অস্থায়ী ফাইলে রাখবে এবং '<()' কে সেই ফাইলের নামের সাথে প্রতিস্থাপন করবে। এটি কার্যকর হয় যখন কমান্ডগুলি STDIN এর পরিবর্তে ফাইল দ্বারা মানগুলি পাস করার আশা করে। উদাহরণস্বরূপ, 'Diff <(ls foo) <(ls bar)' 'foo' এবং 'bar' এর ফাইলের মধ্যে পার্থক্য দেখাবে।


যেহেতু এটি একটি বিশাল তথ্যের আবর্জনা ছিল, আসুন একটি উদাহরণ দেখি যা এই বৈশিষ্ট্যগুলির কয়েকটি প্রদর্শন করে। এটি আমাদের প্রদত্ত আর্গুমেন্টগুলির মাধ্যমে পুনরাবৃত্তি করবে, 'ফোবার' স্ট্রিংয়ের জন্য 'গ্রেপ', এবং যদি এটি না পাওয়া যায় তবে এটি একটি মন্তব্য হিসাবে ফাইলের সাথে যুক্ত করবে।

```bash
#!/bin/bash

echo "Starting program at $(date)" # Date will be substituted

echo "Running program $0 with $# arguments with pid $$"

for file in "$@"; do
    grep foobar "$file" > /dev/null 2> /dev/null
    # When pattern is not found, grep has exit status 1
    # We redirect STDOUT and STDERR to a null register since we do not care about them
    if [[ $? -ne 0 ]]; then
        echo "File $file does not have any foobar, adding one"
        echo "# foobar" >> "$file"
    fi
done
```

তুলনায় আমরা পরীক্ষা করেছি যে '$?' 0 এর সমান নয় কিনা।
ব্যাশ এই ধরণের অনেক তুলনা প্রয়োগ করে-আপনি ম্যানপেজে একটি বিস্তারিত তালিকা খুঁজে পেতে পারেন ['test'] (https://www.man7.org/linux/man-pages/man1/test.1.html)
ব্যাশে তুলনা করার সময়, সাধারণ বন্ধনী '[]'-এর পক্ষে ডাবল বন্ধনী '[]' ব্যবহার করার চেষ্টা করুন। ভুল করার সম্ভাবনা কম যদিও এটি 'শ'-এর জন্য বহনযোগ্য হবে না। আরও বিস্তারিত ব্যাখ্যা পাওয়া যাবে [এখানে] (http://mywiki.wooledge.org/BashFAQ/031)

স্ক্রিপ্ট চালু করার সময়, আপনি প্রায়শই অনুরূপ আর্গুমেন্ট সরবরাহ করতে চাইবেন। ব্যাশের কাছে ফাইলের নাম সম্প্রসারণের মাধ্যমে এই অভিব্যক্তিগুলিকে সহজতর, প্রসারিত করার উপায় রয়েছে। এই কৌশলগুলিকে প্রায়শই শেল _ গ্লোবিং _ হিসাবে উল্লেখ করা হয়।
- ওয়াইল্ডকার্ড-যখনই আপনি কোনও ধরণের ওয়াইল্ডকার্ড ম্যাচ করতে চান, আপনি যথাক্রমে একটি বা যে কোনও পরিমাণ অক্ষরের সাথে মেলাতে '?' এবং '*' ব্যবহার করতে পারেন। উদাহরণস্বরূপ, প্রদত্ত ফাইল 'foo', 'foo1', 'foo2', 'foo10' এবং 'bar', 'rm foo?' কমান্ড 'foo1' এবং 'foo2' মুছে ফেলবে যেখানে 'rm foo *' বার ছাড়া সব মুছে ফেলবে।
- কোঁকড়া ধনুর্বন্ধনী '{}'-যখনই আপনার কমান্ডের একটি সিরিজে একটি সাধারণ সাবস্ট্রিং থাকে, আপনি এটি স্বয়ংক্রিয়ভাবে প্রসারিত করতে ব্যাশের জন্য কোঁকড়া ধনুর্বন্ধনী ব্যবহার করতে পারেন। ফাইল সরানোর বা রূপান্তর করার সময় এটি খুব কাজে আসে।

```bash
convert image.{png,jpg}
# Will expand to
convert image.png image.jpg

cp /path/to/project/{foo,bar,baz}.sh /newpath
# Will expand to
cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath

# Globbing techniques can also be combined
mv *{.py,.sh} folder
# Will move all *.py and *.sh files


mkdir foo bar
# This creates files foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h
touch {foo,bar}/{a..h}
touch foo/x bar/y
# Show differences between files in foo and bar
diff <(ls foo) <(ls bar)
# Outputs
# < x
# ---
# > y
```

<!-- Lastly, pipes `|` are a core feature of scripting. Pipes connect one program's output to the next program's input. We will cover them more in detail in the data wrangling lecture. -->

'ব্যাশ' স্ক্রিপ্ট লেখা জটিল এবং স্বজ্ঞাত হতে পারে। [shellcheck] (https://github.com/koalaman/shellcheck) এর মতো সরঞ্জাম রয়েছে যা আপনাকে আপনার sh/bash স্ক্রিপ্টগুলিতে ত্রুটিগুলি খুঁজে পেতে সহায়তা করবে।

লক্ষ্য করুন যে, টার্মিনাল থেকে কল করার জন্য স্ক্রিপ্টগুলি ব্যাশে লেখার প্রয়োজন নেই। উদাহরণস্বরূপ, এখানে একটি সাধারণ পাইথন স্ক্রিপ্ট রয়েছে যা তার আর্গুমেন্টগুলিকে বিপরীত ক্রমে আউটপুট করেঃ

```python
#!/usr/local/bin/python
import sys
for arg in reversed(sys.argv[1:]):
    print(arg)
```

কার্নেল শেল কমান্ডের পরিবর্তে পাইথন ইন্টারপ্রেটার দিয়ে এই স্ক্রিপ্টটি কার্যকর করতে জানে কারণ আমরা স্ক্রিপ্টের শীর্ষে একটি [শেবাং] (https://en.wikpedia.org/wiki/Shebang_ (Unix)) লাইন অন্তর্ভুক্ত করেছি।
['env'] (https://www.man7.org/linux/man-pages/man1/env.1.html) কমান্ড ব্যবহার করে শেবাং লাইনগুলি লেখার জন্য ভাল অনুশীলন যা আপনার স্ক্রিপ্টগুলির বহনযোগ্যতা বাড়িয়ে, কমান্ডটি সিস্টেমে যেখানেই থাকুক না কেন সমাধান করবে। অবস্থান সমাধানের জন্য, 'env' 'PATH' এনভায়রনমেন্ট ভেরিয়েবল ব্যবহার করবে যা আমরা প্রথম বক্তৃতায় চালু করেছি।
এই উদাহরণের জন্য শেবাং লাইনটি '#!/usr/bin/env python' এর মতো দেখাবে।

শেল ফাংশন এবং স্ক্রিপ্টের মধ্যে কিছু পার্থক্য যা আপনার মনে রাখা উচিত তা হলঃ-ফাংশনগুলি শেলের মতো একই ভাষায় হতে হবে, যখন স্ক্রিপ্টগুলি যে কোনও ভাষায় লেখা যেতে পারে। এই কারণেই চিত্রনাট্যের জন্য একটি শেবাং অন্তর্ভুক্ত করা গুরুত্বপূর্ণ।
- ফাংশনগুলি একবার লোড করা হয় যখন তাদের সংজ্ঞা পড়া হয়। স্ক্রিপ্টগুলি প্রতিবার কার্যকর করার সময় লোড করা হয়। এটি ফাংশনগুলিকে কিছুটা দ্রুত লোড করে তোলে, তবে যখনই আপনি সেগুলি পরিবর্তন করবেন আপনাকে তাদের সংজ্ঞাটি পুনরায় লোড করতে হবে।
- ফাংশনগুলি বর্তমান শেল পরিবেশে কার্যকর করা হয় যেখানে স্ক্রিপ্টগুলি তাদের নিজস্ব প্রক্রিয়ায় কার্যকর হয়। সুতরাং, ফাংশনগুলি এনভায়রনমেন্ট ভ্যারিয়েবল পরিবর্তন করতে পারে, e.g। আপনার বর্তমান ডিরেক্টরি পরিবর্তন করুন, যেখানে স্ক্রিপ্টগুলি পারে না। স্ক্রিপ্টগুলি মান পরিবেশের ভেরিয়েবল দ্বারা পাস করা হবে যা ['রপ্তানি'] ব্যবহার করে রফতানি করা হয়েছে(https://www.man7.org/linux/man-pages/man1/export.1p.html)
যে কোনও প্রোগ্রামিং ভাষার মতো, ফাংশনগুলি মডুলারিটি, কোড পুনঃব্যবহার এবং শেল কোডের স্পষ্টতা অর্জনের জন্য একটি শক্তিশালী গঠন। প্রায়শই শেল স্ক্রিপ্টগুলিতে তাদের নিজস্ব ফাংশনের সংজ্ঞা অন্তর্ভুক্ত থাকে।

#শেল টুলস

#কমান্ড ব্যবহার করার উপায় খুঁজে বের করা

এই মুহুর্তে, আপনি হয়তো ভাবছেন যে 'ls-l', 'mv-i' এবং 'mkdir-p' এর মতো আলিয়াসিং বিভাগে কমান্ডগুলির জন্য ফ্ল্যাগগুলি কীভাবে খুঁজে পাওয়া যায়।
আরও সাধারণভাবে, একটি আদেশ দেওয়া হলে, এটি কী করে এবং এর বিভিন্ন বিকল্পগুলি আপনি কীভাবে খুঁজে বের করবেন?
আপনি সর্বদা গুগলিং শুরু করতে পারেন, কিন্তু যেহেতু ইউনিক্স স্ট্যাকওভারফ্লোর পূর্ববর্তী, তাই এই তথ্য পাওয়ার জন্য অন্তর্নির্মিত উপায় রয়েছে।

যেমনটি আমরা শেল বক্তৃতায় দেখেছি, প্রথম-ক্রমের পদ্ধতিটি হল '-h' বা '-- help' ফ্ল্যাগগুলির সাথে উক্ত কমান্ডটি কল করা। আরও বিস্তারিত পদ্ধতি হল 'ম্যান' কমান্ড ব্যবহার করা।
ম্যানুয়াল জন্য সংক্ষিপ্ত, ['man'] (https://www.man7.org/linux/man-pages/man1/man.1.html) আপনার নির্দিষ্ট কমান্ডের জন্য একটি ম্যানুয়াল পৃষ্ঠা (ম্যানপেজ নামে পরিচিত) সরবরাহ করে।
উদাহরণস্বরূপ, 'man rm' আমাদের আগে দেখানো '-i' ফ্ল্যাগ সহ যে ফ্ল্যাগগুলি নেয় তার সাথে 'rm' কমান্ডের আচরণ আউটপুট করবে।
আসলে, আমি এখন পর্যন্ত প্রতিটি কমান্ডের জন্য যা লিঙ্ক করছি তা হল কমান্ডগুলির জন্য লিনাক্স ম্যানপেজের অনলাইন সংস্করণ।
এমনকি আপনার ইনস্টল করা অ-স্থানীয় কমান্ডগুলিতেও ম্যানপেজ এন্ট্রি থাকবে যদি ডেভেলপার সেগুলি লিখে ইনস্টলেশন প্রক্রিয়ার অংশ হিসাবে অন্তর্ভুক্ত করে।
এনকার্সের উপর ভিত্তি করে ইন্টারেক্টিভ সরঞ্জামগুলির জন্য, কমান্ডগুলির জন্য সহায়তা প্রায়শই ': help' কমান্ড বা টাইপিং '?' ব্যবহার করে প্রোগ্রামের মধ্যে অ্যাক্সেস করা যেতে পারে।

কখনও কখনও ম্যানপেজগুলি কমান্ডগুলির অতিরিক্ত বিশদ বিবরণ প্রদান করতে পারে, যা সাধারণ ব্যবহারের ক্ষেত্রে কোন ফ্ল্যাগ/সিনট্যাক্স ব্যবহার করতে হবে তা বোঝা কঠিন করে তোলে।
[টিএলডিআর পৃষ্ঠাগুলি] (https://tldr.sh/) একটি নিফটি পরিপূরক সমাধান যা একটি কমান্ডের উদাহরণ ব্যবহারের ক্ষেত্রে দৃষ্টি নিবদ্ধ করে যাতে আপনি কোন বিকল্পগুলি ব্যবহার করবেন তা দ্রুত নির্ধারণ করতে পারেন।
উদাহরণস্বরূপ, আমি নিজেকে ম্যানপেজের চেয়ে প্রায়শই ['টার'] (https://tldr.inbrowser.app/pages/common/tar) এবং ['ffmpeg'] (https://tldr.inbrowser.app/pages/common/ffmpeg) এর জন্য টিএলডিআর পৃষ্ঠাগুলিতে উল্লেখ করছি।


##ফাইল খুঁজে বের করা

প্রতিটি প্রোগ্রামার যে সবচেয়ে সাধারণ পুনরাবৃত্তিমূলক কাজের মুখোমুখি হয় তার মধ্যে একটি হল ফাইল বা ডিরেক্টরি খুঁজে বের করা।
সমস্ত ইউনিক্স-মত সিস্টেমগুলি ['সন্ধান'] (https://www.man7.org/linux/man-pages/man1/find.1.html) ফাইলগুলি খুঁজে পেতে একটি দুর্দান্ত শেল সরঞ্জামের সাথে প্যাকেজ করা হয়। 'ফাইন্ড' কিছু মানদণ্ডের সাথে মিলে যাওয়া ফাইলগুলির জন্য পুনরাবৃত্তভাবে অনুসন্ধান করবে। কিছু উদাহরণঃ

```bash
# Find all directories named src
find . -name src -type d
# Find all python files that have a folder named test in their path
find . -path '*/test/*.py' -type f
# Find all files modified in the last day
find . -mtime -1
# Find all zip files with size in range 500k to 10M
find . -size +500k -size -10M -name '*.tar.gz'
```
ফাইলগুলি তালিকাভুক্ত করার বাইরে, ফাইন্ড আপনার প্রশ্নের সাথে মেলে এমন ফাইলগুলির উপরও কাজ করতে পারে।
এই বৈশিষ্ট্যটি মোটামুটি একঘেয়ে কাজগুলি সহজ করার জন্য অবিশ্বাস্যভাবে সহায়ক হতে পারে।
```bash
# Delete all files with .tmp extension
find . -name '*.tmp' -exec rm {} \;
# Find all PNG files and convert them to JPG
find . -name '*.png' -exec convert {} {}.jpg \;
```

'ফাইন্ড'-এর সর্বব্যাপীতা সত্ত্বেও, এর বাক্যবিন্যাস কখনও কখনও মনে রাখা কঠিন হতে পারে।
উদাহরণস্বরূপ, 'প্যাটার্ন' প্যাটার্নের সাথে মেলে এমন ফাইলগুলি খুঁজে পেতে আপনাকে 'ফাইন্ড-নেম' * প্যাটার্ন * '(অথবা'-নেম 'যদি আপনি প্যাটার্নটি কেস সংবেদনশীল হতে চান) এক্সিকিউট করতে হবে।
আপনি সেই পরিস্থিতিগুলির জন্য উপনাম তৈরি করা শুরু করতে পারেন, কিন্তু শেল দর্শনের অংশ হল বিকল্পগুলি অন্বেষণ করা ভাল।
মনে রাখবেন, শেলের সর্বোত্তম বৈশিষ্ট্যগুলির মধ্যে একটি হল যে আপনি কেবল প্রোগ্রামগুলিতে কল করছেন, যাতে আপনি কিছু বিকল্প খুঁজে পেতে পারেন (এমনকি নিজেকে লিখতে পারেন)।
উদাহরণস্বরূপ, ['fd'] (https://github.com/sharkdp/fd) একটি সহজ, দ্রুত এবং ব্যবহারকারী-বান্ধব বিকল্প 'খুঁজুন'।
এটি রঙিন আউটপুট, ডিফল্ট রেজেক্স ম্যাচিং এবং ইউনিকোড সাপোর্টের মতো কিছু ভাল ডিফল্ট অফার করে। আমার মতে, এটির আরও স্বজ্ঞাত বাক্য গঠন রয়েছে।
উদাহরণস্বরূপ, 'প্যাটার্ন' প্যাটার্ন খুঁজে বের করার জন্য সিনট্যাক্স হল 'এফডি প্যাটার্ন'।

বেশিরভাগই একমত হবেন যে 'ফাইন্ড' এবং 'এফডি' ভাল, তবে আপনারা কেউ কেউ হয়তো দ্রুত অনুসন্ধানের জন্য কোনও ধরণের সূচক বা ডাটাবেস সংকলন বনাম প্রতিবার ফাইল খোঁজার দক্ষতা সম্পর্কে ভাবছেন।
এটাই ['locate'] (https://www.man7.org/linux/man-pages/man1/locate.1.html) এর জন্য।
'লোকেট' একটি ডাটাবেস ব্যবহার করে যা ['updateb'] ব্যবহার করে আপডেট করা হয় (https://www.man7.org/linux/man-pages/man1/updatedb.1.html)
বেশিরভাগ সিস্টেমে, 'আপডেটবি' প্রতিদিন ['ক্রন'] এর মাধ্যমে আপডেট করা হয় (https://www.man7.org/linux/man-pages/man8/cron.8.html)
অতএব, উভয়ের মধ্যে একটি বিনিময় হল গতি বনাম সতেজতা।
উপরন্তু 'সন্ধান' এবং অনুরূপ সরঞ্জামগুলি ফাইলের আকার, পরিবর্তনের সময় বা ফাইল অনুমতির মতো বৈশিষ্ট্যগুলি ব্যবহার করে ফাইলগুলি খুঁজে পেতে পারে, যখন 'অবস্থান' কেবল ফাইলের নাম ব্যবহার করে।
আরও গভীরতার তুলনা পাওয়া যাবে [এখানে] (https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other)


##কোড খুঁজুন

নাম অনুসারে ফাইল খুঁজে পাওয়া দরকারী, তবে প্রায়শই আপনি ফাইল * কন্টেন্ট *-এর উপর ভিত্তি করে অনুসন্ধান করতে চান। 
একটি সাধারণ দৃশ্যপট হল এমন সমস্ত ফাইল অনুসন্ধান করা যেখানে কিছু প্যাটার্ন রয়েছে, সেই ফাইলগুলির মধ্যে কোথায় প্যাটার্ন রয়েছে।
এটি অর্জনের জন্য, বেশিরভাগ ইউনিক্স-মত সিস্টেমগুলি ['grep'] (https://www.man7.org/linux/man-pages/man1/grep.1.html) ইনপুট পাঠ্য থেকে নিদর্শনগুলি মেলানোর জন্য একটি জেনেরিক সরঞ্জাম সরবরাহ করে।
'গ্রেপ' একটি অবিশ্বাস্যভাবে মূল্যবান শেল টুল যা আমরা ডেটা রেঙ্গলিং বক্তৃতার সময় আরও বিস্তারিতভাবে কভার করব।

আপাতত, জেনে রাখুন যে 'গ্রেপ'-এর অনেকগুলি পতাকা রয়েছে যা এটিকে একটি বহুমুখী সরঞ্জাম করে তোলে।
কিছু আমি প্রায়শই ব্যবহার করি '-সি' মেলানো লাইনের চারপাশে * * সি * * টেক্সট পাওয়ার জন্য এবং '-ভি' এর জন্য * * ভি * * ম্যাচটি ইর্ট করার জন্য, i.e। প্যাটার্নের সাথে মেলে না এমন সমস্ত লাইন মুদ্রণ করুন। উদাহরণস্বরূপ, 'গ্রেপ-সি 5' ম্যাচের আগে এবং পরে 5টি লাইন প্রিন্ট করবে।
যখন অনেক ফাইলের মাধ্যমে দ্রুত অনুসন্ধানের কথা আসে, তখন আপনি '-R' ব্যবহার করতে চান কারণ এটি * * R * * ইকারসিভভাবে ডিরেক্টরিগুলিতে যাবে এবং ম্যাচিং স্ট্রিংয়ের জন্য ফাইলগুলি সন্ধান করবে।

কিন্তু 'grep-R' অনেক উপায়ে উন্নত করা যেতে পারে, যেমন '. git' ফোল্ডার উপেক্ষা করা, মাল্টি সিপিইউ সমর্থন ব্যবহার করা, এবং সি।
অনেকগুলি 'গ্রেপ' বিকল্প তৈরি করা হয়েছে, যার মধ্যে রয়েছে [ack] (https://github.com/beyondgrep/ack3) [ag] (https://github.com/ggreer/the_silver_searcher) এবং [rg] (https://github.com/BurntSushi/ripgrep)
এগুলির সবগুলিই দুর্দান্ত এবং প্রায় একই কার্যকারিতা সরবরাহ করে।
এই মুহুর্তে আমি রিপগ্রেপ ('আরজি') এর সাথে লেগে আছি এটি কতটা দ্রুত এবং স্বজ্ঞাত। কিছু উদাহরণঃ
```bash
# Find all python files where I used the requests library
rg -t py 'import requests'
# Find all files (including hidden files) without a shebang line
rg -u --files-without-match "^#\!"
# Find all matches of foo and print the following 5 lines
rg foo -A 5
# Print statistics of matches (# of matched lines and files )
rg --stats PATTERN
```

মনে রাখবেন যে 'ফাইন্ড'/'এফডি' এর মতো, এটি গুরুত্বপূর্ণ যে আপনি জানেন যে এই সমস্যাগুলি এই সরঞ্জামগুলির মধ্যে একটি ব্যবহার করে দ্রুত সমাধান করা যেতে পারে, যদিও আপনি যে নির্দিষ্ট সরঞ্জামগুলি ব্যবহার করেন সেগুলি ততটা গুরুত্বপূর্ণ নয়।

##শেল কমান্ড খুঁজে বের করা

এখন পর্যন্ত আমরা দেখেছি কিভাবে ফাইল এবং কোড খুঁজে বের করতে হয়, কিন্তু যখন আপনি শেলের মধ্যে আরও বেশি সময় ব্যয় করতে শুরু করেন, তখন আপনি কোনও সময়ে টাইপ করা নির্দিষ্ট কমান্ডগুলি খুঁজে পেতে চাইতে পারেন।
প্রথমে যা জানতে হবে তা হল উপরের তীরটি টাইপ করা আপনাকে আপনার শেষ কমান্ডটি ফিরিয়ে দেবে এবং আপনি যদি এটি টিপতে থাকেন তবে আপনি ধীরে ধীরে আপনার শেল ইতিহাসের মধ্য দিয়ে যাবেন।

'ইতিহাস' কমান্ড আপনাকে প্রোগ্রামগতভাবে আপনার শেল ইতিহাস অ্যাক্সেস করতে দেবে।
এটি আপনার শেলের ইতিহাসকে স্ট্যান্ডার্ড আউটপুটে মুদ্রণ করবে।
আমরা যদি সেখানে অনুসন্ধান করতে চাই তবে আমরা সেই আউটপুটটি 'গ্রেপ'-এ পাইপ করতে পারি এবং নিদর্শনগুলি অনুসন্ধান করতে পারি।
'হিস্টোরি। grep ফাইন্ড' এমন কমান্ড প্রিন্ট করবে যা সাবস্ট্রিং 'ফাইন্ড' ধারণ করে।

বেশিরভাগ শেলগুলিতে, আপনি 'Ctrl + R' ব্যবহার করে আপনার ইতিহাস জুড়ে পিছনের দিকে অনুসন্ধান করতে পারেন।
'Ctrl + R' চাপার পর, আপনি আপনার ইতিহাসে কমান্ডের সাথে মিল রাখতে চান এমন একটি সাবস্ট্রিং টাইপ করতে পারেন।
আপনি যখন এটি চাপতে থাকবেন, আপনি আপনার ইতিহাসের ম্যাচগুলির মধ্য দিয়ে সাইকেল চালাবেন।
এটি [zsh] এ UP/DOWN তীর দিয়ে সক্ষম করা যেতে পারে (https://github.com/zsh-users/zsh-history-substring-search)
'Ctrl + R' এর উপরে একটি চমৎকার সংযোজন [fzf] (https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings #ctrl-r) বাইন্ডিং ব্যবহার করে আসে।
'fzf' একটি সাধারণ উদ্দেশ্যের ফাজি ফাইন্ডার যা অনেক কমান্ডের সাথে ব্যবহার করা যেতে পারে।
এখানে এটি আপনার ইতিহাসের সাথে অস্পষ্টভাবে মেলাতে এবং সুবিধাজনক এবং দৃশ্যত আনন্দদায়ক পদ্ধতিতে ফলাফল উপস্থাপন করতে ব্যবহৃত হয়।

ইতিহাস সম্পর্কিত আরেকটি চমৎকার কৌশল যা আমি সত্যিই উপভোগ করি তা হল * * ইতিহাস-ভিত্তিক স্ব-পরামর্শ * *।
প্রথমে [মাছ] (https://fishshell.com/) শেল দ্বারা প্রবর্তিত, এই বৈশিষ্ট্যটি গতিশীলভাবে আপনার বর্তমান শেল কমান্ডটিকে আপনি টাইপ করেছেন এমন সাম্প্রতিকতম কমান্ডের সাথে স্বয়ংক্রিয়ভাবে সম্পন্ন করে যা এটির সাথে একটি সাধারণ উপসর্গ ভাগ করে।
এটি [zsh] (https://github.com/zsh-users/zsh-autosuggestions) এ সক্ষম করা যেতে পারে এবং এটি আপনার শেলের জন্য একটি দুর্দান্ত মানের জীবন কৌশল।

আপনি আপনার শেলের ইতিহাসের আচরণ পরিবর্তন করতে পারেন, যেমন একটি নেতৃস্থানীয় স্থান সহ কমান্ডগুলিকে অন্তর্ভুক্ত করা থেকে বিরত রাখা। আপনি যখন পাসওয়ার্ড বা অন্যান্য সংবেদনশীল তথ্য দিয়ে কমান্ড টাইপ করেন তখন এটি কাজে আসে।
এটি করার জন্য, আপনার '. bashrc' তে 'HISTCONTROL = Ignorespace' অথবা আপনার '. zshrc' এ 'setopt HIST _ IGNORE _ SPACE' যোগ করুন।
আপনি যদি শীর্ষস্থানীয় স্থান যোগ না করার ভুল করেন তবে আপনি সর্বদা আপনার '. bash _ history' বা '. zsh _ history' সম্পাদনা করে ম্যানুয়ালি এন্ট্রিটি সরিয়ে ফেলতে পারেন।

##ডিরেক্টরি নেভিগেশন

এখন পর্যন্ত, আমরা ধরে নিয়েছি যে এই ক্রিয়াগুলি সম্পাদন করার জন্য আপনার যেখানে থাকা দরকার সেখানে আপনি ইতিমধ্যে রয়েছেন। কিন্তু কিভাবে আপনি দ্রুত ডিরেক্টরি নেভিগেট করবেন?
আপনি এটি করতে পারেন এমন অনেকগুলি সহজ উপায় রয়েছে, যেমন শেল উপনামগুলি লেখা বা [ln-s] (https://www.man7.org/linux/man-pages/man1/ln.1.html) এর সাথে সিমলিঙ্ক তৈরি করা তবে সত্যটি হ 'ল বিকাশকারীরা এখন বেশ চতুর এবং পরিশীলিত সমাধানগুলি খুঁজে পেয়েছেন।

এই কোর্সের থিমের মতো, আপনি প্রায়শই সাধারণ ক্ষেত্রে অপ্টিমাইজ করতে চান।
ঘন ঘন এবং/অথবা সাম্প্রতিক ফাইল এবং ডিরেক্টরিগুলি সন্ধান করা ['fasd'] (https://github.com/clvv/fasd) এবং ['autojump'] (https://github.com/wting/autojump) এর মতো সরঞ্জামগুলির মাধ্যমে করা যেতে পারে।
Fasd ফাইল এবং ডিরেক্টরিগুলিকে [_ Frecency _] (https://web.archive.org/web/20210421120120/https:// developer. mozilla. org/en-US/docs/Mozilla/Tech/Places/Frecency _ algorithm) দ্বারা স্থান দেয়, অর্থাৎ _ frequency _ এবং _ recency _ উভয় দ্বারা।
ডিফল্টরূপে, 'fasd' একটি 'z' কমান্ড যোগ করে যা আপনি a _ frecent _ directory এর একটি সাবস্ট্রিং ব্যবহার করে দ্রুত 'cd' ব্যবহার করতে পারেন। উদাহরণস্বরূপ, আপনি যদি প্রায়শই '/home/user/files/কূল _ প্রজেক্ট'-এ যান তবে সেখানে ঝাঁপ দেওয়ার জন্য আপনি কেবল 'z কুল' ব্যবহার করতে পারেন। অটোজাম্প ব্যবহার করে, ডিরেক্টরির এই একই পরিবর্তন 'জে কুল' ব্যবহার করে সম্পন্ন করা যেতে পারে।

ডিরেক্টরি কাঠামোর একটি সংক্ষিপ্ত বিবরণ দ্রুত পেতে আরও জটিল সরঞ্জাম রয়েছেঃ ['বৃক্ষ'] (https://linux.die.net/man/1/tree) ['ব্রুট'] (https://github.com/Canop/broot) বা এমনকি ['nnn'] (https://github.com/jarun/nnn) বা ['রেঞ্জার'] (https://github.com/ranger/ranger)

# ব্যায়াম

1টি। পড়ুন ['man ls'] (https://www.man7.org/linux/man-pages/man1/ls.1.html) এবং একটি 'ls' কমান্ড লিখুন যা নিম্নলিখিত পদ্ধতিতে ফাইলগুলি তালিকাভুক্ত করে

    - লুকানো ফাইল সহ সমস্ত ফাইল অন্তর্ভুক্ত করে
    - আকারগুলি মানব পাঠযোগ্য বিন্যাসে তালিকাভুক্ত করা হয়েছে (e.g. 454M instead of 454279954)
    - ফাইলগুলি পুনরাবৃত্তি দ্বারা অর্ডার করা হয়-আউটপুট রঙিন করা হয়

    একটি নমুনা আউটপুট এইরকম দেখাবে

    '-rw-r---- 1 ব্যবহারকারী গ্রুপ 1.1 M জানুয়ারী 14.09:53 বাজ drwxr-xr-x 5 ব্যবহারকারী গ্রুপ 160 জানুয়ারি 14.09:53. - rw-r---- 1 ব্যবহারকারী গ্রুপ  514 জানুয়ারি 14.06:42 বার
    - rw-r---- 1 ব্যবহারকারী গ্রুপ 106M জানুয়ারী 13.12:12 foo drwx-------+ 47 ব্যবহারকারী গ্রুপ 1.5 K জানুয়ারি 12.18:8..
    ```

{% comment %}
ls-lath-- রঙ = স্বয়ংক্রিয়
{% endcomment %}

1টি। ব্যাশ ফাংশন 'মার্কো' এবং 'পোলো' লিখুন যা নিম্নলিখিতগুলি করে।
যখনই আপনি 'মার্কো' এক্সিকিউট করবেন তখন বর্তমান ওয়ার্কিং ডিরেক্টরিটি কোনওভাবে সংরক্ষণ করা উচিত, তারপর যখন আপনি 'পোলো' এক্সিকিউট করবেন, আপনি যে ডিরেক্টরিতে থাকুন না কেন, 'পোলো' আপনাকে সেই ডিরেক্টরিতে 'সিডি' করতে হবে যেখানে আপনি 'মার্কো' এক্সিকিউট করেছেন।
ডিবাগিংয়ের স্বাচ্ছন্দ্যের জন্য আপনি একটি ফাইলে কোডটি লিখতে পারেন 'marco.sh' এবং (পুনরায়) 'source marco.sh' এক্সিকিউট করে আপনার শেলটিতে সংজ্ঞা লোড করুন।

{% comment %} মার্কো () {রপ্তানি মার্কো = $(পিডব্লিউডি)}

পোলো () {cd "$MARCO"}
{% endcomment %}

1টি। ধরুন আপনার কাছে এমন একটি কমান্ড রয়েছে যা খুব কমই ব্যর্থ হয়। এটিকে ডিবাগ করার জন্য আপনাকে এর আউটপুট ক্যাপচার করতে হবে তবে ব্যর্থতা চালাতে সময় লাগতে পারে।
একটি ব্যাশ স্ক্রিপ্ট লিখুন যা নিম্নলিখিত স্ক্রিপ্টটি চালায় যতক্ষণ না এটি ব্যর্থ হয় এবং এর স্ট্যান্ডার্ড আউটপুট এবং ত্রুটি ফাইলগুলিতে প্রবাহিত হয় এবং শেষে সবকিছু মুদ্রণ করে।
বোনাস পয়েন্ট যদি আপনি স্ক্রিপ্টটি ব্যর্থ হতে কত রান লেগেছে তাও জানাতে পারেন।

    'বাশ #!/ইউএসআর/বিন/এনভ বাশ

    n = $((র্যান্ডম% 100))

    যদি [[n-eq 42]]; তারপর প্রতিধ্বনি "কিছু ভুল হয়েছে"> এবং 2 প্রতিধ্বনি "ত্রুটিটি জাদু সংখ্যা ব্যবহার করছিল" প্রস্থান 1 ফাই

    প্রতিধ্বনি 'সবকিছু পরিকল্পনা অনুযায়ী হয়েছে' '

{% comment %} #!/usr/bin/env bash

গণনা = 0 পর্যন্ত ["$?" - ne 0]]; do ঎ণ্ণ = $((গণনা + 1))./random. sh &> out.txt সম্পন্ন

echo "$count run এর পরে ত্রুটি পাওয়া গেছে" cat out.txt {% endcomment %}

1টি। যেমনটি আমরা এই বক্তৃতায় উল্লেখ করেছি যে আমরা যে ফাইলগুলি খুঁজছি সেগুলির উপর অপারেশন সম্পাদনের জন্য 's'-exec 'খুব শক্তিশালী হতে পারে।
কিন্তু, আমরা যদি * * সমস্ত * * ফাইল দিয়ে জিপ ফাইল তৈরি করার মতো কিছু করতে চাই, তাহলে কী হবে?
আপনি এখন পর্যন্ত দেখেছেন যে কমান্ডগুলি আর্গুমেন্ট এবং STDIN উভয় থেকে ইনপুট নেবে।
কমান্ডগুলি পাইপ করার সময়, আমরা STDOUT-কে STDIN-এর সাথে সংযুক্ত করছি, তবে 'টার'-এর মতো কিছু কমান্ড আর্গুমেন্ট থেকে ইনপুট নেয়।
এই সংযোগ বিচ্ছিন্ন করার জন্য ['xargs'] (https://www.man7.org/linux/man-pages/man1/xargs.1.html) কমান্ড রয়েছে যা STDIN কে আর্গুমেন্ট হিসাবে ব্যবহার করে একটি কমান্ড কার্যকর করবে।
উদাহরণস্বরূপ, 'ls। xargs rm' বর্তমান ডিরেক্টরির ফাইলগুলি মুছে ফেলবে।

    আপনার কাজ হল একটি কমান্ড লেখা যা পুনরাবৃত্তভাবে ফোল্ডারে সমস্ত এইচটিএমএল ফাইল খুঁজে পায় এবং সেগুলি দিয়ে একটি জিপ তৈরি করে। মনে রাখবেন যে ফাইলগুলিতে স্পেস থাকলেও আপনার কমান্ডটি কাজ করবে (ইঙ্গিতঃ 'xargs'-এর জন্য '-d' ফ্ল্যাগ পরীক্ষা করুন)
    {% comment %} খুঁজে বের করুন। - type f-name "*. html"। xargs-d '\n' tor-cvzf archive.tar.gz
    {% endcomment %}

    আপনি যদি ম্যাকোসে থাকেন তবে মনে রাখবেন যে ডিফল্ট বিএসডি 'সন্ধান' [জিএনইউ কোরুটিলস] (https://en.wikpedia.org/wiki/List_of_GNU_Core_Utilities_commands) এর অন্তর্ভুক্ত একটির থেকে আলাদা। আপনি 'ফাইন্ড'-এ '-print0' এবং 'xargs'-এ '-0' ফ্ল্যাগ ব্যবহার করতে পারেন। ম্যাকোস ব্যবহারকারী হিসাবে, আপনার সচেতন হওয়া উচিত যে ম্যাকোসের সাথে প্রেরিত কমান্ড-লাইন ইউটিলিটিগুলি জিএনইউ সমকক্ষদের থেকে পৃথক হতে পারে; আপনি যদি চান তবে জিএনইউ সংস্করণগুলি ইনস্টল করতে পারেন [ব্রিউ ব্যবহার করে] (https://formulee.brew.sh/formula/coreutils)

1. (Advanced) একটি ডিরেক্টরিতে সাম্প্রতিকতম পরিবর্তিত ফাইলটি পুনরাবৃত্তিমূলকভাবে খুঁজে পেতে একটি কমান্ড বা স্ক্রিপ্ট লিখুন। আরও সাধারণভাবে, আপনি কি পুনরাবৃত্তি অনুসারে সমস্ত ফাইল তালিকাভুক্ত করতে পারেন?
