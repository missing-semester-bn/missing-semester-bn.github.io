---
layout: lecture
title: "কোর্স ওভারভিউ  + the shell"
date: 2020-01-13
ready: true
video:
  aspect: 56.25
  id: Z56Jmr9Z34Q
---

# অনুপ্রেরণা

কম্পিউটার বিজ্ঞানী হিসাবে, আমরা জানি যে পুনরাবৃত্তিমূলক কাজে কম্পিউটার দুর্দান্ত সহায়তা করে। যাইহোক, প্রায়শই, আমরা ভুলে যাই যে এটি আমাদের কম্পিউটারের _ব্যবহারের_ ক্ষেত্রে ঠিক ততটাই প্রযোজ্য যতটা আমরা আমাদের প্রোগ্রামগুলি সম্পাদন করতে চাই এমন গণনার ক্ষেত্রে প্রযোজ্য। আমাদের হাতের মুঠোয় প্রচুর সরঞ্জাম রয়েছে যা কম্পিউটার সম্পর্কিত যে কোনও সমস্যায় কাজ করার সময় আমাদের আরও উত্পাদনশীল হতে এবং আরও জটিল সমস্যা সমাধান করতে সক্ষম করে। তবুও আমরা অনেকেই এই সরঞ্জামগুলির একটি ছোট অংশই ব্যবহার করি; আমরা কেবল রটের মাধ্যমে যথেষ্ট যাদুকরী মন্ত্রগুলি জানি এবং আটকে গেলে ইন্টারনেট থেকে অন্ধভাবে আদেশগুলি copy-paste করি।

এই ক্লাসটি এটি সমাধান করার একটি প্রচেষ্টা।

আমরা আপনাকে শেখাতে চাই যে, কীভাবে আপনার পরিচিত সরঞ্জামগুলির সর্বাধিক ব্যবহার করা যায়, আপনার টুলবক্সে যোগ করার জন্য আপনাকে নতুন সরঞ্জাম দেখাব এবং আশা করি আপনার নিজের উপর আরও সরঞ্জাম অন্বেষণ (এবং সম্ভবত নির্মাণ) করার জন্য আপনার মধ্যে কিছু উত্তেজনা জাগিয়ে তুলবে।
এটিই আমরা বেশিরভাগ কম্পিউটার বিজ্ঞান পাঠ্যক্রমের অনুপস্থিত সেমিস্টার বলে মনে করি।

# শ্রেণী কাঠামো

ক্লাসটিতে 11.1-ঘন্টা বক্তৃতা রয়েছে, প্রতিটি একটি [নির্দিষ্ট বিষয়](/2020/) কেন্দ্র করে বক্তৃতাগুলি মূলত স্বাধীন, যদিও সেমিস্টারে যাওয়ার সাথে সাথে আমরা ধরে নেব যে আপনি আগের বক্তৃতাগুলির বিষয়বস্তুর সাথে পরিচিত। আমাদের অনলাইনে লেকচার নোট রয়েছে, তবে ক্লাসে প্রচুর সামগ্রী থাকবে (e.g। ডেমো আকারে) যা নোটগুলিতে নাও থাকতে পারে। আমরা বক্তৃতা রেকর্ড করব এবং রেকর্ডিং অনলাইনে পোস্ট করব।

আমরা মাত্র 11.1-ঘন্টা বক্তৃতাগুলির মধ্যে অনেকগুলি স্থল কভার করার চেষ্টা করছি, তাই বক্তৃতাগুলি মোটামুটি ঘন। আপনার নিজস্ব গতিতে বিষয়বস্তুর সাথে পরিচিত হওয়ার জন্য আপনাকে কিছু সময় দেওয়ার জন্য, প্রতিটি বক্তৃতায় অনুশীলনের একটি সেট অন্তর্ভুক্ত থাকে যা আপনাকে বক্তৃতার মূল পয়েন্টগুলির মাধ্যমে গাইড করে। প্রতিটি বক্তৃতার পরে, আমরা অফিসের সময়গুলি হোস্ট করছি যেখানে আপনার যে কোনও প্রশ্নের উত্তর দিতে আমরা উপস্থিত থাকব। আপনি যদি অনলাইনে ক্লাসে অংশ নিচ্ছেন তবে আপনি আমাদের প্রশ্ন পাঠাতে পারেন [missing-semester@mit.edu](mailto:missing-semester@mit.edu)

আমাদের সীমিত সময়ের কারণে, আমরা সমস্ত সরঞ্জামগুলিকে একই স্তরের বিশদে একটি পূর্ণ-স্কেল শ্রেণীর শক্তিতে কভার করতে সক্ষম হব না। যেখানে সম্ভব, আমরা আপনাকে কোনও সরঞ্জাম বা বিষয়ে আরও খনন করার জন্য সংস্থানগুলির দিকে নির্দেশ করার চেষ্টা করব, তবে যদি কিছু বিশেষভাবে আপনার কল্পনাকে আঘাত করে তবে আমাদের কাছে পৌঁছাতে এবং পয়েন্টারগুলির জন্য জিজ্ঞাসা করতে দ্বিধা করবেন না!

# বিষয় 1: দ্য shell

# shell কি?

আজকাল কম্পিউটারগুলিতে command দেওয়ার জন্য বিভিন্ন ধরনের ইন্টারফেস রয়েছে; কল্পনাপ্রসূত গ্রাফিক্যাল ইউজার ইন্টারফেস, ভয়েস ইন্টারফেস এবং এমনকি এআর/ভিআর সর্বত্র রয়েছে। এগুলি 80% ব্যবহারের ক্ষেত্রে দুর্দান্ত, তবে তারা আপনাকে যা করতে দেয় তা প্রায়শই মৌলিকভাবে সীমাবদ্ধ থাকে-আপনি এমন কোনও বোতাম টিপতে পারবেন না যা সেখানে নেই বা এমন কোনও ভয়েস command দিতে পারবেন না যা প্রোগ্রাম করা হয়নি। আপনার কম্পিউটার যে সরঞ্জামগুলি সরবরাহ করে তার পুরো সুবিধা নিতে, আমাদের পুরানো স্কুলে যেতে হবে এবং একটি পাঠ্য ইন্টারফেসে নামতে হবেঃ shell।

প্রায় সমস্ত প্ল্যাটফর্ম যা আপনি আপনার হাতে পেতে পারেন সেগুলির কোনও না কোনও রূপে একটি খোল থাকে এবং সেগুলির মধ্যে অনেকগুলিতে আপনার বেছে নেওয়ার জন্য বেশ কয়েকটি খোল থাকে।
যদিও এগুলি বিশদে পরিবর্তিত হতে পারে, তাদের মূলে এগুলি মোটামুটি একই রকমঃ এগুলি আপনাকে প্রোগ্রাম চালানোর অনুমতি দেয়, তাদের ইনপুট দেয় এবং আধা-কাঠামোগত উপায়ে তাদের আউটপুট পরিদর্শন করে।

এই বক্তৃতায়, আমরা Bourne Again SHell বা সংক্ষেপে "bash"-এর দিকে মনোনিবেশ করব। এটি সর্বাধিক ব্যবহৃত shell গুলির মধ্যে একটি এবং এর সিনট্যাক্স আপনি অন্যান্য অনেক shell গুলিতে যা দেখতে পাবেন তার অনুরূপ। shell _prompt_ খুলতে (যেখানে আপনি command টাইপ করতে পারেন) প্রথমে আপনার একটি _terminal_ প্রয়োজন।
আপনার ডিভাইসটি সম্ভবত ইনস্টল করা একটি দিয়ে পাঠানো হয়েছে, অথবা আপনি মোটামুটি সহজেই একটি ইনস্টল করতে পারেন।

## shell ব্যবহার করা

আপনি যখন আপনার টার্মিনাল চালু করবেন, তখন আপনি একটি _prompt_ দেখতে পাবেন যা প্রায়শই কিছুটা এরকম দেখায়ঃ

```console
missing:~$ 
```

এটি শেলের প্রধান পাঠ্য ইন্টারফেস। এটি আপনাকে বলে যে আপনি `missing` মেশিনে আছেন এবং আপনার "current working directory" বা আপনি বর্তমানে যেখানে আছেন, তা `~` (short for "home"). `$` আপনাকে বলে যে আপনি root user নন। (এ বিষয়ে পরে আরও). এই প্রম্পটে আপনি _command_ টাইপ করতে পারেন, যা তারপর shell দ্বারা ব্যাখ্যা করা হবে। সবচেয়ে মৌলিক command হল একটি প্রোগ্রাম এক্সিকিউট করাঃ

```console
missing:~$ date
Fri 10 Jan 2020 11:49:31 AM EST
missing:~$ 
```

এখানে, আমরা `date` প্রোগ্রামটি কার্যকর করেছি, যা (সম্ভবত আশ্চর্যজনকভাবে) বর্তমান তারিখ এবং সময় মুদ্রণ করে। shell তারপর আমাদের এক্সিকিউট করার জন্য আরেকটি command চায়। আমরা _argument_ দিয়ে একটি command ও চালাতে পারিঃ

```console
missing:~$ echo hello
hello
```

এই ক্ষেত্রে, আমরা shellকে `hello` যুক্তি সহ `echo` প্রোগ্রামটি কার্যকর করতে বলেছিলাম। `echo` প্রোগ্রামটি কেবল তার argumentগুলি প্রিন্ট করে।
shellটি হোয়াইটস্পেস দ্বারা বিভক্ত করে command টি বিশ্লেষণ করে এবং তারপরে প্রথম শব্দ দ্বারা নির্দেশিত প্রোগ্রামটি চালায়, প্রতিটি পরবর্তী শব্দকে একটি যুক্তি হিসাবে সরবরাহ করে যা প্রোগ্রামটি অ্যাক্সেস করতে পারে। যদি আপনি স্পেস বা অন্যান্য বিশেষ অক্ষর (e.g., "My Photos" নামে একটি ডিরেক্টরি) রয়েছে এমন একটি argument সরবরাহ করতে চান তবে আপনি `'` বা `"` (`"My Photos`) দিয়ে argumentটি উদ্ধৃত করতে পারেন বা কেবল প্রাসঙ্গিক অক্ষরগুলি `\` (`My\ Photos`) দিয়ে এড়াতে পারেন।

কিন্তু shell টি কীভাবে `date` বা `echo` প্রোগ্রামগুলি খুঁজে বের করতে জানে?
ঠিক আছে, shell টি একটি programming এনভায়রনমেন্ট, ঠিক যেমন পাইথন বা রুবি, এবং তাই এটিতে ভেরিয়েবল, শর্তাধীন, লুপ এবং ফাংশন রয়েছে (পরবর্তী বক্তৃতা! ) আপনি যখন আপনার শেলের মধ্যে command চালান, আপনি সত্যিই একটি ছোট কোড লিখছেন যা আপনার shell ব্যাখ্যা করে। যদি shell টিকে এমন কোনও command চালানোর জন্য বলা হয় যা তার কোনও programming কীওয়ার্ডের সাথে মেলে না, তবে এটি  `$PATH` নামে একটি _environment variable_ এর পরামর্শ নেয় যা একটি command দেওয়া হলে shellকে কোন ডিরেক্টরিগুলি প্রোগ্রামগুলির জন্য অনুসন্ধান করা উচিত তা তালিকাভুক্ত করেঃ

```console
missing:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
missing:~$ which echo
/bin/echo
missing:~$ /bin/echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

যখন আমরা `echo` commandটি চালাই, তখন shell টি দেখে যে এটি  `echo` প্রোগ্রামটি কার্যকর করবে, এবং তারপর সেই নামের একটি ফাইলের জন্য `$PATH`-এ ডিরেক্টরিগুলির `:`-বিচ্ছিন্ন তালিকার মাধ্যমে অনুসন্ধান করে। যখন এটি পাওয়া যায়, এটি এটি চালায় (ধরে নেওয়া যায় যে ফাইলটি _executable_; আরও পরে) আমরা `which` প্রোগ্রাম ব্যবহার করে একটি প্রদত্ত প্রোগ্রামের নামের জন্য কোন ফাইলটি এক্সিকিউট করা হয়েছে তা খুঁজে বের করতে পারি। আমরা যে ফাইলটি এক্সিকিউট করতে চাই সেটিকে _path_ দিয়ে `$PATH` কে সম্পূর্ণভাবে বাইপাস করতে পারি।

# শেলের মধ্যে চলাচল করা

শেলের একটি পাথ হল ডিরেক্টরিগুলির একটি সীমাবদ্ধ তালিকা; লিনাক্স এবং ম্যাকোসে `/` এবং উইন্ডোজে `\` দ্বারা পৃথক করা হয়েছে। লিনাক্স এবং ম্যাকোসে, পাথ `/` হল ফাইল সিস্টেমের `root`, যার অধীনে সমস্ত ডিরেক্টরি এবং ফাইল থাকে, যেখানে উইন্ডোজে প্রতিটি ডিস্ক পার্টিশনের জন্য একটি রুট থাকে (e.g., `C:\`) আমরা সাধারণত ধরে নেব যে আপনি এই ক্লাসে একটি লিনাক্স ফাইল সিস্টেম ব্যবহার করছেন। `/` দিয়ে শুরু হওয়া পথকে an _absolute_ path বলা হয়।
অন্য যে কোনও পথ হল a _relative_ path। আপেক্ষিক পথগুলি বর্তমান কার্যকরী ডিরেক্টরির সাথে সম্পর্কিত, যা আমরা `pwd` command দিয়ে দেখতে পারি এবং `cd` command দিয়ে পরিবর্তন করতে পারি। একটি পথে, `.` বর্তমান ডিরেক্টরিকে বোঝায়, এবং `..` এর মূল ডিরেক্টরিকে বোঝায়ঃ

```console
missing:~$ pwd
/home/missing
missing:~$ cd /home
missing:/home$ pwd
/home
missing:/home$ cd ..
missing:/$ pwd
/
missing:/$ cd ./home
missing:/home$ pwd
/home
missing:/home$ cd missing
missing:~$ pwd
/home/missing
missing:~$ ../../bin/echo hello
hello
```

লক্ষ্য করুন যে আমাদের shell প্রম্পট আমাদের বর্তমান কার্যকরী ডিরেক্টরি সম্পর্কে অবহিত করে রেখেছিল। আপনাকে সব ধরনের দরকারী তথ্য দেখানোর জন্য আপনি আপনার প্রম্পটটি কনফিগার করতে পারেন, যা আমরা পরবর্তী বক্তৃতায় কভার করব।

সাধারণভাবে, যখন আমরা একটি প্রোগ্রাম চালাই, এটি বর্তমান ডিরেক্টরিতে কাজ করবে যদি না আমরা এটি অন্যথায় বলি। উদাহরণস্বরূপ, এটি সাধারণত সেখানে ফাইল অনুসন্ধান করবে এবং প্রয়োজন হলে সেখানে নতুন ফাইল তৈরি করবে।

প্রদত্ত ডিরেক্টরিতে কী থাকে তা দেখতে, আমরা `ls` commandটি ব্যবহার করিঃ

```console
missing:~$ ls
missing:~$ cd ..
missing:/home$ ls
missing
missing:/home$ cd ..
missing:/$ ls
bin
boot
dev
etc
home
...
```

যদি না কোনও ডিরেক্টরিকে তার প্রথম argument হিসাবে দেওয়া হয়, `ls` বর্তমান ডিরেক্টরির বিষয়বস্তু মুদ্রণ করবে। বেশিরভাগ command ফ্ল্যাগ এবং বিকল্পগুলি (মান সহ ফ্ল্যাগ) গ্রহণ করে যা তাদের আচরণ পরিবর্তন করতে `-` দিয়ে শুরু হয়। সাধারণত, `-h` বা `-- help` ফ্ল্যাগ সহ একটি প্রোগ্রাম চালানো কিছু সহায়তা পাঠ্য মুদ্রণ করবে যা আপনাকে বলে যে কোন ফ্ল্যাগ এবং বিকল্পগুলি উপলব্ধ। উদাহরণস্বরূপ, `ls-- help` আমাদের বলেঃ

```
  -l                         use a long listing format
```

```console
missing:~$ ls -l /home
drwxr-xr-x 1 missing  users  4096 Jun 15  2019 missing
```

এটি আমাদের উপস্থিত প্রতিটি ফাইল বা ডিরেক্টরি সম্পর্কে আরও তথ্য দেয়। প্রথমত, লাইনের শুরুতে `d` আমাদের বলে যে `missing` একটি ডিরেক্টরি। তারপর তিনটি অক্ষরের তিনটি গ্রুপ অনুসরণ করুন (`rwx`) এগুলি নির্দেশ করে যে ফাইলের মালিক (`missing`) মালিকানাধীন গোষ্ঠী (`users`) এবং অন্যান্য প্রত্যেকের যথাক্রমে প্রাসঙ্গিক আইটেমে কী অনুমতি রয়েছে। একটি `-` নির্দেশ করে যে প্রদত্ত মূলধনের প্রদত্ত অনুমতি নেই। উপরে, শুধুমাত্র মালিককে (`w`) `missing` ডিরেক্টরি (i.e., এতে ফাইল যুক্ত/অপসারণ) সংশোধন করার অনুমতি দেওয়া হয়। একটি ডিরেক্টরি প্রবেশ করতে, একজন ব্যবহারকারীর অবশ্যই সেই ডিরেক্টরিতে "search" ("execute": `x` দ্বারা প্রতিনিধিত্ব করা) অনুমতি থাকতে হবে। (and its parents). এর বিষয়বস্তু তালিকাভুক্ত করতে, একজন ব্যবহারকারীর অবশ্যই সেই ডিরেক্টরিতে পড়ার (`r`) অনুমতি থাকতে হবে। ফাইলগুলির জন্য, অনুমতিগুলি আপনি যেমন আশা করবেন তেমন। লক্ষ্য করুন যে `/bin`-এর প্রায় সমস্ত ফাইলের শেষ গ্রুপের জন্য `x` অনুমতি সেট করা আছে, "অন্য সবাই", যাতে যে কেউ সেই প্রোগ্রামগুলি চালাতে পারে।

এই মুহুর্তে আরও কিছু সহজ প্রোগ্রাম সম্পর্কে জানতে হবে `mv` (একটি ফাইলের নাম পরিবর্তন/সরানোর জন্য) `cp` (একটি ফাইল অনুলিপি করার জন্য) এবং `mkdir` (একটি নতুন ডিরেক্টরি তৈরি করার জন্য)।

আপনি যদি কখনও কোনও প্রোগ্রামের argument, ইনপুট, আউটপুট বা এটি সাধারণভাবে কীভাবে কাজ করে সে সম্পর্কে আরও তথ্য চান তবে `man` প্রোগ্রামটি চেষ্টা করে দেখুন। এটি একটি যুক্তি হিসাবে একটি প্রোগ্রামের নাম নেয় এবং আপনাকে এর _ম্যানুয়াল পৃষ্ঠা_ দেখায়। প্রস্থান করতে `q` টিপুন।

```console
missing:~$ man ls
```

## প্রোগ্রাম সংযোগ করা হচ্ছে

shellটিতে, প্রোগ্রামগুলির সাথে দুটি প্রাথমিক "স্ট্রিম" যুক্ত থাকেঃ তাদের ইনপুট স্ট্রিম এবং তাদের আউটপুট স্ট্রিম। যখন প্রোগ্রামটি ইনপুট পড়ার চেষ্টা করে, তখন এটি ইনপুট স্ট্রিম থেকে পড়ে এবং যখন এটি কিছু প্রিন্ট করে, তখন এটি তার আউটপুট স্ট্রিমটিতে প্রিন্ট করে। সাধারণত, একটি প্রোগ্রামের ইনপুট এবং আউটপুট উভয়ই আপনার টার্মিনাল। অর্থাৎ, ইনপুট হিসাবে আপনার কীবোর্ড এবং আউটপুট হিসাবে আপনার স্ক্রিন। যাইহোক, আমরা সেই প্রবাহগুলিকেও পুনর্বিন্যস্ত করতে পারি!

পুনর্নির্দেশের সহজতম রূপ হল `<file` এবং `> file`। এগুলি আপনাকে একটি প্রোগ্রামের ইনপুট এবং আউটপুট স্ট্রিমগুলি যথাক্রমে একটি ফাইলে রিওয়াইয়ার করতে দেয়ঃ

```console
missing:~$ echo hello > hello.txt
missing:~$ cat hello.txt
hello
missing:~$ cat < hello.txt
hello
missing:~$ cat < hello.txt > hello2.txt
missing:~$ cat hello2.txt
hello
```

উপরের উদাহরণে দেখানো হয়েছে, `cat` এমন একটি প্রোগ্রাম যা ফাইলগুলিকে একত্রিত করে। যখন ফাইলের নামগুলি argument হিসাবে দেওয়া হয়, তখন এটি প্রতিটি ফাইলের বিষয়বস্তুগুলি তার আউটপুট প্রবাহে ক্রমানুসারে মুদ্রণ করে। কিন্তু যখন `cat` কে কোনও argument দেওয়া হয় না, তখন এটি তার ইনপুট স্ট্রিম থেকে তার আউটপুট স্ট্রিমের বিষয়বস্তু প্রিন্ট করে (যেমন উপরের তৃতীয় উদাহরণে)

আপনি একটি ফাইলের সাথে যুক্ত করতে `>>` ব্যবহার করতে পারেন। যেখানে এই ধরনের ইনপুট/আউটপুট পুনর্নির্দেশ সত্যিই জ্বলজ্বল করে _pipes_ এর ব্যবহারে। `।` অপারেটর আপনাকে "চেইন" প্রোগ্রাম দেয় যাতে একটির আউটপুট অন্যটির ইনপুট হয়ঃ

```console
missing:~$ ls -l / | tail -n1
drwxr-xr-x 1 root  root  4096 Jun 20  2019 var
missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=' ' -f2
219
```

ডেটা রেঙ্গলিং (data wrangling)-এর বক্তৃতায় আমরা পাইপের সুবিধা কীভাবে নেওয়া যায় সে সম্পর্কে আরও বিশদে যাব।

#একটি বহুমুখী এবং শক্তিশালী হাতিয়ার

বেশিরভাগ ইউনিক্স-সদৃশ সিস্টেমে, একজন ব্যবহারকারী বিশেষঃ "রুট" ব্যবহারকারী। আপনি হয়তো উপরের ফাইল তালিকাগুলিতে এটি দেখেছেন। রুট ব্যবহারকারী (প্রায়) সমস্ত প্রবেশাধিকার সীমাবদ্ধতার উপরে রয়েছে এবং সিস্টেমে যে কোনও ফাইল তৈরি, পড়তে, আপডেট এবং মুছে ফেলতে পারে। আপনি সাধারণত রুট ব্যবহারকারী হিসাবে আপনার সিস্টেমে লগ ইন করবেন না, কারণ দুর্ঘটনাক্রমে কিছু ভেঙে ফেলা খুব সহজ।
পরিবর্তে, আপনি `sudo` command ব্যবহার করবেন। এর নাম থেকে বোঝা যায়, এটি আপনাকে সু হিসাবে কিছু "করতে" দেয়। (short for "super user", or "root").
যখন আপনি অনুমতিপ্রাপ্ত ত্রুটিগুলি অস্বীকার করেন, তখন এটি সাধারণত হয় কারণ আপনাকে মূল হিসাবে কিছু করতে হবে। যদিও নিশ্চিত করুন যে আপনি প্রথমে দুইবার পরীক্ষা করে দেখুন যে আপনি সত্যিই এটি এভাবে করতে চেয়েছিলেন!

একটি কাজ করার জন্য আপনাকে রুট হতে হবে `/sys` এর অধীনে মাউন্ট করা `sysfs` ফাইল সিস্টেমে লেখা। `sysfs` ফাইল হিসাবে বেশ কয়েকটি কার্নেল পরামিতি প্রকাশ করে, যাতে আপনি সহজেই বিশেষ সরঞ্জাম ছাড়াই ফ্লাইতে কার্নেলটি পুনরায় কনফিগার করতে পারেন। **মনে রাখবেন যে উইন্ডোজ বা ম্যাকোসে sysfs বিদ্যমান নেই।**

উদাহরণস্বরূপ, আপনার ল্যাপটপের স্ক্রিনের উজ্জ্বলতা নীচের `brightness` নামক একটি ফাইলের মাধ্যমে প্রকাশিত হয়।

```
/sys/class/backlight
```

সেই ফাইলে একটি মান লিখে আমরা পর্দার উজ্জ্বলতা পরিবর্তন করতে পারি।
আপনার প্রথম প্রবৃত্তি হতে পারে এরকম কিছু করাঃ

```console
$ sudo find -L /sys/class/backlight -maxdepth 2 -name '*brightness*'
/sys/class/backlight/thinkpad_screen/brightness
$ cd /sys/class/backlight/thinkpad_screen
$ sudo echo 3 > brightness
An error occurred while redirecting file 'brightness'
open: Permission denied
```

এই ভুলটি অবাক করে দিতে পারে। সর্বোপরি, আমরা `সুডো` দিয়ে commandটি চালিয়েছি! shell সম্পর্কে এটি জানা একটি গুরুত্বপূর্ণ বিষয়। `।`, `>`, এবং `<` এর মতো ক্রিয়াকলাপগুলি shell দ্বারা করা হয়, পৃথক প্রোগ্রাম দ্বারা নয়। `echo` এবং বন্ধুরা `।` সম্পর্কে `জানে` না। তারা কেবল তাদের ইনপুট থেকে পড়ে এবং তাদের আউটপুটে লেখে, যাই হোক না কেন। উপরের ক্ষেত্রে, _shell_ (যা আপনার ব্যবহারকারীর মতো প্রমাণীকরণ করা হয়েছে) brightness ফাইলটি `sudo echo` s আউটপুট হিসাবে সেট করার আগে লেখার জন্য খোলার চেষ্টা করে, তবে shell টি root হিসাবে না চলার কারণে এটি করা থেকে বিরত থাকে। এই জ্ঞান ব্যবহার করে, আমরা এর চারপাশে কাজ করতে পারিঃ

```console
$ echo 3 | sudo tee brightness
```

যেহেতু `tee` প্রোগ্রামটি লেখার জন্য `/sys` ফাইলটি খুলবে এবং  `root` হিসাবে চলছে, তাই সমস্ত অনুমতি কার্যকর হয়। আপনি `/sys`-এর মাধ্যমে সব ধরনের মজার এবং দরকারী জিনিস নিয়ন্ত্রণ করতে পারেন, যেমন বিভিন্ন সিস্টেম LED-র অবস্থা (আপনার পথ ভিন্ন হতে পারে)

```console
$ echo 1 | sudo tee /sys/class/leds/input6::scrolllock/brightness
```

#পরবর্তী ধাপ

এই মুহুর্তে আপনি মৌলিক কাজগুলি সম্পন্ন করার জন্য যথেষ্ট একটি শেলের চারপাশে আপনার পথ জানেন। আপনার আগ্রহের ফাইলগুলি খুঁজে পেতে এবং বেশিরভাগ প্রোগ্রামের মৌলিক কার্যকারিতা ব্যবহার করতে সক্ষম হওয়া উচিত। পরবর্তী বক্তৃতায়, আমরা shell এবং সেখানকার অনেক সহজ command-লাইন প্রোগ্রাম ব্যবহার করে আরও জটিল কাজগুলি কীভাবে সম্পাদন এবং স্বয়ংক্রিয় করা যায় সে সম্পর্কে কথা বলব।

# Exercise

এই কোর্সের সমস্ত ক্লাসের সঙ্গে একাধিক অনুশীলন করা হয়। কেউ কেউ আপনাকে একটি নির্দিষ্ট কাজ দেয়, অন্যরা ওপেন-এন্ডেড, যেমন "এক্স এবং ওয়াই প্রোগ্রাম ব্যবহার করার চেষ্টা করুন"। আমরা আপনাকে এগুলি চেষ্টা করার জন্য অত্যন্ত উৎসাহিত করি।

অনুশীলনের জন্য আমরা কোনও লিখিত সমাধান পাইনি। আপনি যদি বিশেষ কিছুতে আটকে থাকেন, তাহলে আপনি এখন পর্যন্ত কী চেষ্টা করেছেন তা বর্ণনা করে আমাদের একটি ইমেল পাঠাতে নির্দ্বিধায়, এবং আমরা আপনাকে সাহায্য করার চেষ্টা করব।

1.  এই কোর্সের জন্য আপনাকে Bash বা ZSH-এর মতো Unix shell ব্যবহার করতে হবে। আপনি যদি Linux বা macOS থাকেন, তাহলে আপনাকে বিশেষ কিছু করতে হবে না। আপনি যদি Windows থাকেন তবে আপনাকে নিশ্চিত করতে হবে যে আপনি cmd.exe বা PowerShell চালাচ্ছেন না; আপনি ইউনিক্স-স্টাইল command-লাইন সরঞ্জামগুলি ব্যবহার করতে [Windows Subsystem for Linux](https://docs.microsoft.com/en-us/windows/wsl/) বা একটি virtual machine মেশিন ব্যবহার করতে পারেন। আপনি একটি উপযুক্ত shell চালাচ্ছেন কিনা তা নিশ্চিত করতে, আপনি `echo $SHELL` commandটি ব্যবহার করতে পারেন। যদি এটি `/bin/bash` বা `/usr/bin/zsh` এর মতো কিছু বলে, তার মানে আপনি সঠিক প্রোগ্রামটি চালাচ্ছেন।
1. `/tmp` এর অধীনে `missing` নামে একটি নতুন ডিরেক্টরি তৈরি করুন।
1. `touch` প্রোগ্রামটি দেখুন। `man` প্রোগ্রামটি আপনার বন্ধু।
1. `missing`-এ `semester` নামে একটি নতুন ফাইল তৈরি করতে `touch` ব্যবহার করুন।
1. সেই ফাইলে নিম্নলিখিতগুলি লিখুন, একবারে একটি লাইনঃ
```
#!/bin/sh
curl --head --silent https://missing.csail.mit.edu
```
    প্রথম লাইনটি কাজ করা কঠিন হতে পারে। এটা জানা সহায়ক যে `#` bash ভাষায় একটি মন্তব্য শুরু করে এবং `!`-এর একটি বিশেষ অর্থ রয়েছে এমনকি দ্বি-উদ্ধৃত (`"`) স্ট্রিংয়ের মধ্যেও। bash একক-উদ্ধৃত স্ট্রিং (`'`) কে ভিন্নভাবে বিবেচনা করেঃ তারা এই ক্ষেত্রে কৌশলটি করবে। আরও তথ্যের জন্য bash [quoting](https://www.gnu.org/software/bash/manual/html_node/Quoting.html) ম্যানুয়াল পৃষ্ঠা দেখুন।
1. ফাইলটি চালানোর চেষ্টা করুন, i.e। আপনার শেলের মধ্যে স্ক্রিপ্টের পথ (`./semester`) টাইপ করুন এবং এন্টার টিপুন। `ls` এর আউটপুটের সাথে পরামর্শ করে কেন এটি কাজ করে না তা বুঝুন (ইঙ্গিতঃ ফাইলের অনুমতি বিটগুলি দেখুন)
1. স্পষ্টভাবে `sh` ইন্টারপ্রেটার শুরু করে commandটি চালান এবং এটিকে প্রথম argument হিসাবে `semester` ফাইলটি দিন, i.e। `sh semester`। কেন এটি কাজ করে, যখন `./semester` কাজ করে না?
1. `chmod` প্রোগ্রামটি দেখুন (e.g। `man chmod` ব্যবহার করুন)
1. `sh semester` টাইপ করার পরিবর্তে `./semester` commandটি চালানো সম্ভব করতে `chmod` ব্যবহার করুন। আপনার shell কিভাবে জানে যে ফাইলটি `sh` ব্যবহার করে ব্যাখ্যা করার কথা? আরও তথ্যের জন্য [shebang](https://en.wikpedia.org/wiki/Shebang_ (Unix)) লাইনে এই পৃষ্ঠাটি দেখুন।
1. আপনার হোম ডিরেক্টরিতে `last-modified.txt` নামে একটি ফাইলে `semester` দ্বারা `last-modified.txt` তারিখ আউটপুট লিখতে `।` এবং `>` ব্যবহার করুন।
1. একটি command লিখুন যা আপনার ল্যাপটপ ব্যাটারির পাওয়ার স্তর বা আপনার ডেস্কটপ মেশিনের সিপিইউ তাপমাত্রা `/sys` থেকে পড়ে। দ্রষ্টব্যঃ আপনি যদি একজন ম্যাকোস ব্যবহারকারী হন, তাহলে আপনার অপারেটিং সিস্টেমে sysfs নেই, তাই আপনি এই অনুশীলনটি এড়িয়ে যেতে পারেন।

